# AI 异步分析前端 MVP v4 - 渐进式编码开发计划

## 文档说明

本文档是基于《需求文档 MVP v4》和《详细设计文档 LLD》制定的渐进式小步迭代编码步骤。每个步骤都是独立、完整、可验证的，确保程序在每一步完成后都能成功启动并保持可运行状态。

---

## 一、代码目录结构

```
web/vibe_coding/
├── app.py                      # Flask 服务器主程序 (约120行)
├── static/
│   ├── index.html              # 前端主页面 (约150行)
│   ├── app.js                  # 前端核心逻辑 (约350行)
│   └── style.css               # 基础样式 (约150行)
├── readme_frontend_mvp_lld.md  # 详细设计文档
├── readme_mvp_codingplan.md    # 本文档
└── 需求文档.md                  # 需求文档
```

**文件行数说明**：所有文件均控制在500行以内，符合模块化策略要求。

---

## 二、受影响的现有模块说明

本项目为**全新项目**，无需修改已有模块。所有代码文件从零开始创建。

### 当前状态
- `vibe_coding/` 目录已存在
- 仅包含文档文件：`需求文档.md` 和 `readme_frontend_mvp_lld.md`

### 需要新建的模块
1. **Flask 后端服务** (`app.py`)：微型回调服务器
2. **静态资源目录** (`static/`)：存放前端页面和资源
3. **前端页面** (`static/index.html`, `app.js`, `style.css`)：用户交互界面

---

## 三、渐进式小步迭代开发步骤

### 步骤 1：创建 Flask 基础服务器（可运行的最小系统）

**目标**：搭建能够启动的 Flask 服务器，提供静态文件服务和健康检查接口。

**文件操作**：
- 新建 `app.py`
- 新建 `static/` 目录
- 新建 `static/index.html`（仅包含欢迎文本）

**功能范围**：
1. Flask 服务器监听 `0.0.0.0:5000`
2. 提供根路由 `/`，返回 `static/index.html`
3. 添加健康检查路由 `GET /health`，返回 `{"status": "ok"}`

**验证方式**：
- 启动服务：`python app.py`
- 浏览器访问 `http://localhost:5000/`，看到欢迎页面
- 访问 `http://localhost:5000/health`，看到 JSON 响应

**代码要点**：

```python
# app.py 核心结构
from flask import Flask, send_from_directory, jsonify
import os

app = Flask(__name__)


@app.route('/')
def index():
    return send_from_directory('../static', 'index.html')


@app.route('/health')
def health():
    return jsonify({"status": "ok"})


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=False)
```

**步骤产出**：
- ✅ 可启动的 Flask 服务器
- ✅ 可访问的基础 HTML 页面

---

### 步骤 2：实现 Flask 回调接收和结果查询接口

**目标**：添加 AI 后端回调接收接口和前端轮询查询接口，使用内存存储任务结果。

**文件操作**：
- 修改 `app.py`，新增两个路由

**功能范围**：
1. 新增全局变量 `task_results = {}` 用于内存存储
2. 实现 `POST /callback`：接收 AI 后端回调，存储结果
3. 实现 `GET /get-result?taskId=xxx`：供前端轮询查询结果

**验证方式**：
- 使用 Postman 或 curl 模拟回调：
  ```bash
  curl -X POST http://localhost:5000/callback \
    -H "Content-Type: application/json" \
    -d '{"taskId":"test-123","status":"SUCCESS","data":{}}'
  ```
  期望返回：`{"status": "received"}`

- 查询结果：
  ```bash
  curl http://localhost:5000/get-result?taskId=test-123
  ```
  期望返回：存储的完整 JSON

**代码要点**：
```python
# 在 app.py 中添加
task_results = {}  # 全局内存存储

@app.route('/callback', methods=['POST'])
def callback():
    data = request.get_json()
    if not data or 'taskId' not in data:
        return jsonify({"error": "Missing taskId"}), 400
    
    task_id = data['taskId']
    task_results[task_id] = data
    return jsonify({"status": "received"}), 200

@app.route('/get-result', methods=['GET'])
def get_result():
    task_id = request.args.get('taskId')
    if not task_id:
        return jsonify({"error": "taskId is required"}), 400
    
    if task_id in task_results:
        return jsonify(task_results[task_id]), 200
    else:
        return jsonify({"status": "pending"}), 404
```

**步骤产出**：
- ✅ 功能完整的回调接收接口
- ✅ 功能完整的结果查询接口
- ✅ 内存存储机制

---

### 步骤 3：创建前端基础 HTML 结构和样式

**目标**：构建完整的 HTML 表单结构和基础 CSS 样式，使页面具备可用的视觉效果。

**文件操作**：
- 修改 `static/index.html`（替换为完整表单结构）
- 新建 `static/style.css`

**功能范围**：
1. HTML 包含所有必需的表单元素（任务类型选择、文件上传、患者信息表单）
2. HTML 包含结果展示区域（加载图标、结果容器、复制按钮）
3. CSS 提供基础样式（布局、表单样式、按钮样式、旋转动画）
4. 所有动态显示/隐藏的元素初始状态正确

**验证方式**：
- 刷新浏览器，看到完整的表单界面
- 检查页面布局是否居中、样式是否正常
- 检查加载图标旋转动画是否流畅（手动移除 `hidden` 类测试）

**HTML 核心元素**：
```html
<!-- index.html 关键 DOM 元素 -->
<div class="container">
  <h1>AI 异步分析测试平台</h1>
  
  <!-- 任务类型选择 -->
  <div class="form-group">
    <label for="taskType">任务类型：</label>
    <select id="taskType">
      <option value="panoramic">全景片 (Panoramic)</option>
      <option value="cephalometric">侧位片 (Cephalometric)</option>
    </select>
  </div>
  
  <!-- 文件选择 -->
  <div class="form-group">
    <label for="imageFile">选择文件：</label>
    <input type="file" id="imageFile" accept=".jpg,.jpeg,.png,.dcm">
  </div>
  
  <!-- 患者信息表单（动态显示） -->
  <div id="patientInfoSection" class="form-group hidden">
    <label>患者信息（侧位片图片必填）：</label>
    <select id="gender">
      <option value="">请选择性别</option>
      <option value="Male">男性 (Male)</option>
      <option value="Female">女性 (Female)</option>
    </select>
    <select id="dentalStage">
      <option value="">请选择牙期</option>
      <option value="Permanent">恒牙期 (Permanent)</option>
      <option value="Mixed">混合牙期 (Mixed)</option>
    </select>
  </div>
  
  <!-- 提交按钮 -->
  <button id="submitBtn">提交分析任务</button>
  
  <!-- 加载图标 -->
  <div id="loadingIndicator" class="loading-spinner hidden"></div>
  
  <!-- 结果展示 -->
  <div id="resultContainer" class="hidden">
    <h2>分析结果</h2>
    <pre id="resultJson"></pre>
    <button id="copyBtn">复制完整结果</button>
  </div>
</div>
```

**CSS 核心样式**：
```css
/* style.css 关键样式 */
.container {
  max-width: 800px;
  margin: 50px auto;
  padding: 20px;
}

.hidden {
  display: none !important;
}

.loading-spinner {
  width: 50px;
  height: 50px;
  border: 5px solid #f3f3f3;
  border-top: 5px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 20px auto;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
```

**步骤产出**：
- ✅ 完整的 HTML 页面结构
- ✅ 可用的 CSS 样式
- ✅ 响应式布局和加载动画

---

### 步骤 4：实现前端动态表单逻辑（任务类型 + 文件选择联动）

**目标**：实现核心的动态表单显示逻辑，根据任务类型和文件类型自动显示/隐藏患者信息表单。

**文件操作**：
- 新建 `static/app.js`

**功能范围**：
1. 页面加载时初始化事件监听器
2. 监听 `taskType` 和 `imageFile` 的 `change` 事件
3. 实现核心判断逻辑：
   - 如果 `taskType == 'cephalometric'` 且文件为图片（`.jpg`/`.png`），显示患者信息表单
   - 其他情况隐藏患者信息表单
4. 实现提交按钮的启用/禁用逻辑：
   - 患者信息表单显示时，必须填写完整才能启用提交按钮

**验证方式**：
- 选择"全景片"，患者信息表单应隐藏，提交按钮可用
- 选择"侧位片" + 选择 `.jpg` 文件，患者信息表单显示，提交按钮禁用
- 填写完性别和牙期，提交按钮变为可用
- 选择"侧位片" + 选择 `.dcm` 文件，患者信息表单隐藏，提交按钮可用

**代码要点**：
```javascript
// app.js - 动态表单逻辑
const appState = {
    currentTaskId: null,
    pollingTimer: null,
    pollingStartTime: null,
    cachedResult: null
};

// 页面加载完成后初始化
document.addEventListener('DOMContentLoaded', function() {
    init();
});

function init() {
    // 绑定事件监听器
    document.getElementById('taskType').addEventListener('change', onTaskTypeOrFileChange);
    document.getElementById('imageFile').addEventListener('change', onTaskTypeOrFileChange);
    document.getElementById('gender').addEventListener('change', onPatientInfoChange);
    document.getElementById('dentalStage').addEventListener('change', onPatientInfoChange);
    
    console.log('前端初始化完成');
}

function onTaskTypeOrFileChange() {
    const taskType = document.getElementById('taskType').value;
    const fileInput = document.getElementById('imageFile');
    const file = fileInput.files[0];
    const patientInfoSection = document.getElementById('patientInfoSection');
    const submitBtn = document.getElementById('submitBtn');
    
    // 判断是否需要显示患者信息表单
    let shouldShowPatientInfo = false;
    
    if (taskType === 'cephalometric' && file) {
        const fileName = file.name.toLowerCase();
        const isImage = fileName.endsWith('.jpg') || fileName.endsWith('.jpeg') || fileName.endsWith('.png');
        shouldShowPatientInfo = isImage;
    }
    
    // 更新 UI
    if (shouldShowPatientInfo) {
        patientInfoSection.classList.remove('hidden');
        updateSubmitButtonState();
    } else {
        patientInfoSection.classList.add('hidden');
        submitBtn.disabled = false;
    }
}

function onPatientInfoChange() {
    updateSubmitButtonState();
}

function updateSubmitButtonState() {
    const patientInfoSection = document.getElementById('patientInfoSection');
    const submitBtn = document.getElementById('submitBtn');
    
    // 如果患者信息表单显示，检查是否填写完整
    if (!patientInfoSection.classList.contains('hidden')) {
        const gender = document.getElementById('gender').value;
        const dentalStage = document.getElementById('dentalStage').value;
        submitBtn.disabled = !(gender && dentalStage);
    }
}
```

**步骤产出**：
- ✅ 动态表单逻辑完全正常
- ✅ 提交按钮状态正确管理
- ✅ 用户交互流程顺畅

---

### 步骤 5：实现前端任务提交逻辑（不含轮询）

**目标**：实现任务提交功能，构建 FormData 并发送到 AI 后端，处理提交成功和失败的情况。

**文件操作**：
- 修改 `static/app.js`

**功能范围**：
1. 绑定提交按钮的 `click` 事件
2. 实现任务提交函数 `onSubmit()`：
   - 生成 UUID 作为 `taskId`
   - 构建 `FormData`，包含 `taskId`, `taskType`, `callbackUrl`, `image`
   - 如果需要患者信息，添加 `patientInfo` 字段（JSON 字符串）
   - 发送 `POST` 请求到 AI 后端
3. 处理响应：
   - `202 Accepted`：显示加载图标，暂不轮询（下一步实现）
   - `4xx 错误`：显示错误信息
   - 网络错误：显示通用错误提示

**验证方式**：
- 填写表单后点击提交
- 检查浏览器控制台：
  - 查看生成的 `taskId`（UUID 格式）
  - 查看 `FormData` 内容（通过 `console.log`）
  - 查看网络请求（Network 标签页）
- 由于 AI 后端地址可能不可用，本步骤重点验证：
  - FormData 构建正确
  - 错误处理正常（网络错误时显示提示）
  - 成功时显示加载图标

**代码要点**：
```javascript
// app.js - 添加配置常量和提交函数
const CONFIG = {
    AI_BACKEND_URL: 'http://192.168.1.17:9010/api/v1/analyze',
    CALLBACK_URL: 'http://192.168.1.17:5000/callback',
    POLL_INTERVAL: 3000,       // 3秒
    POLL_TIMEOUT: 360000       // 6分钟
};

function init() {
    // ... 之前的代码 ...
    document.getElementById('submitBtn').addEventListener('click', onSubmit);
}

async function onSubmit() {
    const fileInput = document.getElementById('imageFile');
    const file = fileInput.files[0];
    
    if (!file) {
        alert('请先选择文件');
        return;
    }
    
    // 生成 taskId
    const taskId = crypto.randomUUID();
    console.log('生成任务ID:', taskId);
    
    // 构建 FormData
    const formData = new FormData();
    formData.append('taskId', taskId);
    formData.append('taskType', document.getElementById('taskType').value);
    formData.append('callbackUrl', CONFIG.CALLBACK_URL);
    formData.append('image', file);
    
    // 如果需要患者信息，添加 patientInfo
    const patientInfoSection = document.getElementById('patientInfoSection');
    if (!patientInfoSection.classList.contains('hidden')) {
        const patientInfo = {
            gender: document.getElementById('gender').value,
            DentalAgeStage: document.getElementById('dentalStage').value
        };
        formData.append('patientInfo', JSON.stringify(patientInfo));
        console.log('患者信息:', patientInfo);
    }
    
    // 禁用提交按钮，防止重复提交
    const submitBtn = document.getElementById('submitBtn');
    submitBtn.disabled = true;
    
    try {
        const response = await fetch(CONFIG.AI_BACKEND_URL, {
            method: 'POST',
            body: formData
        });
        
        if (response.status === 202) {
            // 提交成功
            appState.currentTaskId = taskId;
            showLoading();
            console.log('任务提交成功，taskId:', taskId);
            // TODO: 下一步实现轮询
        } else {
            // 同步验证失败
            const errorData = await response.json();
            const errorMsg = errorData.error?.displayMessage || '提交失败';
            alert('错误：' + errorMsg);
            submitBtn.disabled = false;
        }
    } catch (error) {
        console.error('网络错误:', error);
        alert('网络连接失败，请检查后重试');
        submitBtn.disabled = false;
    }
}

function showLoading() {
    document.getElementById('loadingIndicator').classList.remove('hidden');
}

function hideLoading() {
    document.getElementById('loadingIndicator').classList.add('hidden');
}
```

**步骤产出**：
- ✅ 任务提交逻辑完整
- ✅ FormData 构建正确
- ✅ 错误处理完善
- ✅ 加载状态显示

---

### 步骤 6：实现前端轮询逻辑和超时处理

**目标**：在任务提交成功后启动轮询，定期查询任务结果，并处理超时情况。

**文件操作**：
- 修改 `static/app.js`

**功能范围**：
1. 在任务提交成功后调用 `startPolling(taskId)`
2. 实现轮询函数 `startPolling()` 和 `pollResult()`
3. 每 3 秒向 Flask 服务器查询一次结果
4. 实现超时检测（6 分钟），超时后停止轮询并显示错误
5. 实现 `stopPolling()` 函数清理定时器

**验证方式**：
- 提交任务后，观察浏览器控制台：
  - 每 3 秒打印一次轮询日志
  - 查看 Network 标签页，确认每 3 秒发起一次 `GET /get-result` 请求
- 测试超时：等待 6 分钟，确认停止轮询并显示超时错误

**模拟测试方法**：
为了快速测试，可以临时修改 `CONFIG.POLL_TIMEOUT` 为 `15000`（15秒），验证超时逻辑。

**代码要点**：
```javascript
// app.js - 添加轮询逻辑
async function onSubmit() {
    // ... 之前的代码 ...
    
    if (response.status === 202) {
        appState.currentTaskId = taskId;
        showLoading();
        console.log('任务提交成功，taskId:', taskId);
        startPolling(taskId);  // 启动轮询
    }
    
    // ... 其他代码 ...
}

function startPolling(taskId) {
    console.log('开始轮询，taskId:', taskId);
    appState.pollingStartTime = Date.now();
    
    // 立即执行一次
    pollResult(taskId);
    
    // 设置定时器，每 3 秒轮询一次
    appState.pollingTimer = setInterval(() => {
        pollResult(taskId);
    }, CONFIG.POLL_INTERVAL);
}

async function pollResult(taskId) {
    // 检查是否超时
    const elapsed = Date.now() - appState.pollingStartTime;
    if (elapsed > CONFIG.POLL_TIMEOUT) {
        stopPolling();
        hideLoading();
        alert('任务超时，请重试或联系管理员');
        document.getElementById('submitBtn').disabled = false;
        return;
    }
    
    console.log(`轮询中... (已等待 ${Math.floor(elapsed / 1000)} 秒)`);
    
    try {
        const response = await fetch(`/get-result?taskId=${taskId}`);
        
        if (response.status === 200) {
            // 结果已到达
            const resultData = await response.json();
            console.log('收到结果:', resultData);
            stopPolling();
            appState.cachedResult = resultData;
            displayResult(resultData);
        } else if (response.status === 404) {
            // 结果未到达，继续轮询
            console.log('结果未到达，继续等待...');
        } else {
            // 其他错误
            stopPolling();
            hideLoading();
            alert('查询结果时出错');
            document.getElementById('submitBtn').disabled = false;
        }
    } catch (error) {
        console.error('轮询请求失败:', error);
        // 不停止轮询，网络可能暂时中断
    }
}

function stopPolling() {
    if (appState.pollingTimer) {
        clearInterval(appState.pollingTimer);
        appState.pollingTimer = null;
        console.log('停止轮询');
    }
}
```

**步骤产出**：
- ✅ 轮询机制正常工作
- ✅ 超时处理正确
- ✅ 定时器管理完善

---

### 步骤 7：实现结果展示和复制功能

**目标**：在轮询获取到结果后，展示分析结果，并提供复制按钮将完整 JSON 复制到剪贴板。

**文件操作**：
- 修改 `static/app.js`

**功能范围**：
1. 实现 `displayResult(resultJson)` 函数：
   - 隐藏加载图标
   - 根据 `status` 字段判断成功或失败
   - 成功时显示 `data` 字段（格式化 JSON）
   - 失败时显示 `error.displayMessage`
   - 显示结果容器和复制按钮
2. 实现 `onCopy()` 函数：
   - 将 `appState.cachedResult` 完整复制到剪贴板
   - 显示"已复制"提示

**验证方式**：
- 使用 Postman 手动向 Flask 服务器发送回调：
  ```bash
  curl -X POST http://localhost:5000/callback \
    -H "Content-Type: application/json" \
    -d '{
      "taskId":"test-uuid-123",
      "status":"SUCCESS",
      "timestamp":"2025-11-17T10:00:00Z",
      "data":{"result":"测试成功"}
    }'
  ```
- 在前端提交任务时，手动修改 `taskId` 为 `test-uuid-123`
- 观察结果展示：
  - 加载图标消失
  - 显示格式化的 JSON 结果
  - 显示复制按钮
- 点击复制按钮，粘贴到文本编辑器，验证内容正确

**代码要点**：
```javascript
// app.js - 结果展示和复制
function init() {
    // ... 之前的代码 ...
    document.getElementById('copyBtn').addEventListener('click', onCopy);
}

function displayResult(resultJson) {
    hideLoading();
    
    const resultContainer = document.getElementById('resultContainer');
    const resultJsonElement = document.getElementById('resultJson');
    
    // 根据状态显示不同内容
    if (resultJson.status === 'SUCCESS') {
        // 成功：显示 data 字段
        const displayText = '状态：成功\n\n分析结果：\n' + 
                           JSON.stringify(resultJson.data, null, 2);
        resultJsonElement.textContent = displayText;
        resultJsonElement.className = 'result-success';
    } else if (resultJson.status === 'FAILURE') {
        // 失败：显示错误信息
        const errorMsg = resultJson.error?.displayMessage || '未知错误';
        const displayText = '状态：失败\n\n错误信息：\n' + errorMsg;
        resultJsonElement.textContent = displayText;
        resultJsonElement.className = 'result-error';
    } else {
        // 其他状态
        resultJsonElement.textContent = JSON.stringify(resultJson, null, 2);
        resultJsonElement.className = '';
    }
    
    // 显示结果容器
    resultContainer.classList.remove('hidden');
    console.log('结果已展示');
}

async function onCopy() {
    if (!appState.cachedResult) {
        alert('没有可复制的内容');
        return;
    }
    
    const jsonString = JSON.stringify(appState.cachedResult, null, 2);
    
    try {
        await navigator.clipboard.writeText(jsonString);
        
        // 显示"已复制"提示
        const copyBtn = document.getElementById('copyBtn');
        const originalText = copyBtn.textContent;
        copyBtn.textContent = '✓ 已复制';
        
        setTimeout(() => {
            copyBtn.textContent = originalText;
        }, 2000);
        
        console.log('已复制到剪贴板');
    } catch (error) {
        console.error('复制失败:', error);
        alert('复制失败，请手动复制');
    }
}
```

**CSS 补充样式**：
```css
/* style.css - 添加结果样式 */
.result-success {
    background-color: #e8f5e9;
    border: 2px solid #4caf50;
    padding: 15px;
    border-radius: 5px;
}

.result-error {
    background-color: #ffebee;
    border: 2px solid #f44336;
    padding: 15px;
    border-radius: 5px;
}

#resultJson {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-family: 'Courier New', monospace;
    font-size: 14px;
}
```

**步骤产出**：
- ✅ 结果展示功能完整
- ✅ 复制功能正常
- ✅ 成功/失败状态区分明确

---

### 步骤 8：实现 UI 重置逻辑和完整的错误处理

**目标**：实现文件重新选择时的自动重置功能，并完善所有边界情况的错误处理。

**文件操作**：
- 修改 `static/app.js`

**功能范围**：
1. 实现 `resetUI()` 函数：
   - 停止轮询
   - 清空 `appState` 所有字段
   - 隐藏加载图标和结果容器
   - 清空患者信息输入框
   - 重新启用提交按钮
2. 在 `onTaskTypeOrFileChange()` 中检测文件变化，调用 `resetUI()`
3. 完善所有错误处理：
   - 未选择文件时的提示
   - 提交失败的详细错误信息
   - 轮询超时的友好提示
   - Flask 服务器未启动的提示

**验证方式**：
- **测试场景 1**：正常重置流程
  1. 提交任务（进入加载状态）
  2. 在加载过程中重新选择文件
  3. 验证：加载图标消失，轮询停止，界面重置
  
- **测试场景 2**：结果展示后重置
  1. 等待任务完成，显示结果
  2. 重新选择文件
  3. 验证：结果容器隐藏，患者信息清空，界面重置
  
- **测试场景 3**：错误处理
  1. 不选择文件直接点击提交 → 显示"请先选择文件"
  2. 关闭 Flask 服务器，提交任务 → 显示"网络连接失败"
  3. 等待超时 → 显示"任务超时"

**代码要点**：
```javascript
// app.js - UI 重置和错误处理
function onTaskTypeOrFileChange() {
    // 检测是否是文件变化（重新选择文件）
    const fileInput = document.getElementById('imageFile');
    if (fileInput.files.length > 0) {
        // 用户重新选择了文件，触发重置
        if (appState.currentTaskId || appState.pollingTimer) {
            console.log('检测到文件变化，重置 UI');
            resetUI();
        }
    }
    
    // ... 之前的动态表单逻辑 ...
}

function resetUI() {
    console.log('重置 UI');
    
    // 停止轮询
    stopPolling();
    
    // 清空状态
    appState.currentTaskId = null;
    appState.pollingStartTime = null;
    appState.cachedResult = null;
    
    // 隐藏加载和结果
    hideLoading();
    document.getElementById('resultContainer').classList.add('hidden');
    
    // 清空患者信息
    document.getElementById('gender').value = '';
    document.getElementById('dentalStage').value = '';
    
    // 重新启用提交按钮
    document.getElementById('submitBtn').disabled = false;
    
    // 重新检查表单状态
    onTaskTypeOrFileChange();
}
```

**完善错误提示**：
```javascript
// 优化 onSubmit 中的错误处理
async function onSubmit() {
    const fileInput = document.getElementById('imageFile